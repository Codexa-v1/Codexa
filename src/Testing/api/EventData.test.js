// need to change mockEvent to match your event structure in model

import { describe, it, expect, vi, beforeEach } from "vitest";
import {
  createEvent,
  getEvent,
  updateEvent,
  deleteEvent,
  getAllEvents,
} from "../../backend/api/EventData";

// Mock fetch globally
global.fetch = vi.fn();

beforeEach(() => {
  fetch.mockReset();
});

// Example event matching your schema
const mockEvent = {
  id: "1",
  eventPlanner: "auth0|abc123",
  title: "Annual Gala",
  date: "2025-09-21T18:00:00.000Z",
  endDate: "2025-09-21T22:00:00.000Z",
  location: "Grand Ballroom",
  description: "A formal event for all members.",
  status: "Planned",
  budget: 5000,
  capacity: 200,
  category: "Corporate",
  organizer: {
    name: "Jane Doe",
    contact: "123-456-7890",
    email: "jane@example.com"
  },
  startTime: "18:00",
  endTime: "22:00",
  rsvpCurrent: 50,
  rsvpTotal: 200,
  createdAt: "2025-09-01T10:00:00.000Z",
  updatedAt: "2025-09-10T10:00:00.000Z"
};

describe("Event API functions", () => {
  it("createEvent should POST data and return created event", async () => {
    fetch.mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve(mockEvent),
    });

    const eventData = { ...mockEvent };
    delete eventData.id; // id is usually generated by backend

    const result = await createEvent(eventData);

    expect(fetch).toHaveBeenCalledWith(
      expect.stringMatching(/\/api\/events$/),
      expect.objectContaining({
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(eventData),
      })
    );

    expect(result).toEqual(mockEvent);
  });

  it("getEvent should GET an event", async () => {
    fetch.mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve(mockEvent),
    });

    const result = await getEvent("1");

    expect(fetch).toHaveBeenCalledWith(expect.stringMatching(/\/api\/events\/1$/));
    expect(result).toEqual(mockEvent);
  });

  it("updateEvent should PATCH data and return updated event", async () => {
    const updatedEvent = { ...mockEvent, status: "Ongoing" };

    fetch.mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve(updatedEvent),
    });

    const updateData = { status: "Ongoing" };

    const result = await updateEvent("1", updateData);

    expect(fetch).toHaveBeenCalledWith(
      expect.stringMatching(/\/api\/events\/1$/),
      expect.objectContaining({
        method: "PATCH",
        body: JSON.stringify(updateData),
      })
    );

    expect(result).toEqual(updatedEvent);
  });

  it("deleteEvent should DELETE an event", async () => {
    const mockResponse = { success: true };

    fetch.mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve(mockResponse),
    });

    const result = await deleteEvent("1");

    expect(fetch).toHaveBeenCalledWith(expect.stringMatching(/\/api\/events\/1$/), {
      method: "DELETE",
    });

    expect(result).toEqual(mockResponse);
  });

  it("getAllEvents should POST userId and return events list", async () => {
    const mockEvents = [
      mockEvent,
      { ...mockEvent, id: "2", title: "Board Meeting" }
    ];

    fetch.mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve(mockEvents),
    });

    const result = await getAllEvents("auth0|abc123");

    expect(fetch).toHaveBeenCalledWith(expect.stringMatching(/\/api\/events\/all$/), {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ userId: "auth0|abc123" }),
    });

    expect(result).toEqual(mockEvents);
  });

  it("should throw on network error", async () => {
    fetch.mockResolvedValueOnce({ ok: false });

    await expect(getEvent("999")).rejects.toThrow("Network response was not ok");
  });
});
